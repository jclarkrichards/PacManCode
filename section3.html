<!DOCTYPE html>
<html>
  <head>
    <title>Pacman Code</title>
    <link rel="stylesheet" href="style.css">
    <link href='https://fonts.googleapis.com/css?family=Poppins|Press+Start+2P' rel='stylesheet' type='text/css'>  
  </head>

  <body>
    <div id="top"></div>
    <div class="page">
    <div class="navigation">
      <header>
	<h1><img src="Images/pacman.png"/>... Pacman Code ...<img src="Images/pacman.png"/></h1>
	<hr />
	<nav>
	  <ul>
	    <li><a href="index.html">Home</a></li>
	    <li><a href="code.html">Code</a></li>
	    <li><a href="clones.html">Clones</a></li>
	    <li><a href="discuss.html">Discuss</a></li>
	    <li><a href="about.html">About</a></li>
	    <li><a href="contact.html">Contact</a></li>
	  </ul>
	</nav>
      </header>
    </div>

    <hr />
    <h2>Section 3: Moving From Node To Node</h2>
    <div class="container">
      <h3>Setup</h3>
      <p>So the whole point of creating the node map was to constrain Pacman's movement so that he can only move from node to node and nowhere else.  This section will show you how to do that.  This section is actually further divided up into three subsections because we're going to cover three types of node movement.  All of which are good to know and used in this game.  You can jump to the different sections by clicking on the links below or just read from the start.</p>
      <dl>
	<dt><a href="#movement1">Movement 1</a>:</dt>
	<dd>The simplest type of Node to Node movement.  We just jump from Node to Node with no movement in between</dd>
	<dt><a href="#movement2">Movement 2</a>:</dt>
	<dd>We show movement in between the nodes, but we will always stop on each node</dd>
	<dt><a href="#movement3">Movement 3</a>:</dt>
	<dd>The super advanced Node to Node movement that Pacman and the Ghosts will use</dd>
      </dl>
    </div>

    <div class="container">
      <h3 id="movement1">Movement 1</h3>
      <p>Having a map of connected nodes is great, but now we have to teach Pacman how to move around the maze from node to node.  The first type of movement we're going to teach him is simply jumping from node to node.  For example, if he is on Node A and Node A has a neighbor to the LEFT called Node B, then if the player pressed the LEFT key, Pacman would immediately appear on Node B without any indication of movement between the two nodes.  If Node A didn't have a neighbor to the LEFT and the player pressed the LEFT key, then nothing would happen.  This really isn't how Pacman moves around the maze, but it's a first step and has a lot of useful applications and we'll actually use it for some of the things in the game like menu selection and such.  Let's just dive right into the necessary code changes we need to make.  Surprisingly, there isn't that much we need to modify.</p>
      <hr/>

      <div class="pseudoCode">
	<p>The first thing we're going to modify is the pacman.py file.  We need to pass in the list of nodes that make up the maze.  Instead of specifying a random pixel position vector for Pacman to start out on we need to tell him which node we want him to start out on.  Right now it doesn't matter so we'll just have him start out on the first node, so we set his position to be the same as that nodes position.  So nodes is a list of the complete maze and node is the node that Pacman is currently on.  Then we call a method called <span class="mn">setPosition</span>.  We also introduce a temporary variable called "keyDown".  The only reason we have this is so Pacman will only move one node at a time with each key press.</p>
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">__init__</span>(<span class="kw">self</span>, nodes):<br>
	<div class="tabLeft">
	  <span class="kw">self</span>.nodes = nodes<br>
	  <span class="kw">self</span>.node = nodes[0]<br>
	  <span class="kw">self</span>.setPosition()<br>
	  <span class="kw">self</span>.keyDown = <span class="py">False</span>
	</div>
      </div>
      <hr/>

      <div class="pseudoCode">
	<p>All this method really does is copy the node's position to Pacman's position.  We call the copy method because we don't want the same position object associated with Pacman and the node.  If it is then modifying Pacman's position will also modify the nodes position.  The node will basically follow Pacman around.  So instead we copy the position which gives us a fresh new vector to represent Pacman's position.</p>
      </div>
      <div class="codeText">
	<code>
	<span class="kw">def</span> <span class="mn">setPosition</span>(<span class="kw">self</span>):<br>
	<div class="tabLeft">
	  <span class="kw">self</span>.position = <span class="kw">self</span>.node.position.copy()
	</div>
	</code>
      </div>
      <hr/>

      <div class="pseudoCode">
	<p>In the <span class="mn">update</span> method we're going to temporarily comment out the position update.  This is only temporary to show you this type of movement though.</p>
      </div>
      <div class="codeText">
	<code>
	<span class="kw">def</span> <span class="mn">update</span>(<span class="kw">self</span>, dt):<br>
	<div class="tabLeft">
	  <span class="str">#self.position += self.direction*self.speed*dt</span>
	</div>
	</code>
      </div>
      <hr/>

      <div class="pseudoCode">
	<p>We're going to modify the <span class="mn">move</span> method by first checking that the direction isn't equal to the STOP vector and that any keys are being held down.  If the direction is not STOP and a key is being held down, then we need to check further that the node Pacman is currently on has a neighbor in that direction.  If there isn't a neighbor in that direction, then we don't do anything.  If there is a neighbor in that direction, then we set that neighbor as Pacman's current node and call the <span class="mn">setPosition</span> method.  We then set the keyDown variable to <span class="py">True</span> so that Pacman will only move one node with every key press.  </p>
      </div>
      <div class="codeText">
	<code>
	<span class="kw">def</span> <span class="mn">move</span>(<span class="kw">self</span>, direction):<br>
	<div class="tabLeft">
	  <span class="kw">self</span>.direction = direction<br>
	  <span class="kw">if self</span>.direction <span class="kw">is not</span> STOP <span class="kw"> and not self</span>.keyDown:<br>
	  <div class="tabLeft">
	    <span class="kw">if self</span>.node.neighbors[<span class="kw">self</span>.direction] <span class="kw"> is not</span> <span class="py">None</span>:<br>
	    <div class="tabLeft">
	      <span class="kw">self</span>.node = <span class="kw">self</span>.node.neighbors[<span class="kw">self</span>.direction]<br>
	      <span class="kw">self</span>.setPosition()<br>
	      <span class="kw">self</span>.keyDown = <span class="py">True</span>
	    </div>
	  </div>
	</div>
	</code>
      </div>
      <hr/>

      <div class="pseudoCode">
	<p>In the gamecontrol.py method we're going to modify the <span class="mn">startGame</span> method so that we pass in the nodeList into the Pacman object.  We also change it so we create the nodes first, so create the Pacman object after we create the nodes.</p>
      </div>
      <div class="codeText">
	<code>
	<span class="kw">def</span> <span class="mn">startGame</span>(<span class="kw">self</span>):<br>
	<div class="tabLeft">
	  <span class="kw">self</span>.nodes = NodeGroup()<br>
	  <span class="kw">self</span>.nodes.setupTestNodes()<br>
	  <span class="kw">self</span>.pacman = Pacman(<span class="kw">self</span>.nodes.nodeList)
	</div>
	</code>
      </div>
      <hr/>
      
      <div class="pseudoCode">
	<p>In the <span class="mn">checkEvents</span> method we're going to temporarily modify it so that we can check for when the user releases the key.  In which case we reset the keyDown variable to <span class="py">False</span> again.</p>
      </div>
      <div class="codeText">
	<code>
	<span class="kw">def</span> <span class="mn">checkEvents</span>(<span class="kw">self</span>):<br>
	<div class="tabLeft">
	  <span class="kw">for</span> event <span class="kw">in</span> pygame.event.get():<br>
	  <div class="tabLeft">
	    <span class="kw">if</span> event.<span class="py">type</span> == QUIT:<br>
	    <div class="tabLeft">
	      <span class="py">exit</span>()<br>
	    </div>
	    <span class="kw">elif</span> event.<span class="py">type</span> == KEYUP:<br>
	    <div class="tabLeft">
	      <span class="kw">self</span>.pacman.keyDown = <span class="py">False</span>
	    </div>
	  </div>
	</div>
	</code>
      </div>
      </div>
   

    <div class="container">
      <h3 id="movement2">Movement 2</h3>
      <p>So we have Pacman jumping from node to node and that's a great first step.  What we really want is to actually see him moving in between the nodes as well.  In this part we'll have him move in between the nodes, but he'll always stop on each node even if a key is being pressed.  This isn't the final movement for Pacman, but just the next step to fully understanding how he moves within a maze of nodes.  Below is the progression of what we want to happen visually.  Once we have a good visual understanding of what we want to accomplish it will be easier to program.</p>
      <hr/>
      <p>Here is our sample maze with Pacman in the lower right corner.  There are only 2 possible directions he is able to move:  UP and LEFT.  We'll assume the player wants Pacman to move UP.<img src="Images/node2part1.png" alt=""/></p>
      <hr/>
      <p>In this image we see that the player has pressed the UP key which makes Pacman move UP towards the nodes UP neighbor.  Any other key presses won't have any effect on Pacman while he is moving in between two nodes.  <img src="Images/node2part2.png" alt=""/></p>
      <hr/>
      <p>Eventually Pacman will overshoot the node he is trying to reach.  Once we detect this we move Pacman onto the node he was moving towards and make him STOP.<img src="Images/node2part3.png" alt=""/></p>
      <hr/>
      <p><img src="Images/overshoot.png" alt=""/>In order to understand Pacman can overshoot a node and how we check for it I have this image on the right.  I have two nodes labeled 'T' and 'N'.  These letters stand for TARGET and NODE respectively.  The TARGET node is always the node Pacman is moving towards.  The NODE node is always Pacman's current node.  Pacman is always either stationary on his current node or moving away from it.  The top part of the image shows him moving away from his current node and towards the target node.  The bottom part of the image shows the case of him overshooting the target node.  In both cases we're comparing the length between the distance between the two nodes and the distance from the current node to Pacman.  We can easily see that when the distance from the current node to Pacman exheeds the distance from the current node to the target node, then Pacman has overshot the target node.</p>
      <hr/>

      <div class="pseudoCode">
	<p>The first thing we'll do is add the target to the pacman.py file.  The target node is usually the node Pacman needs to move towards, but if Pacman is stationary on a node then the target node and his current node are the same node.  In other words, the target node can never be <span class="py">None</span>.</p>
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">__init__</span>(<span class="kw">self</span>, nodes):<br>
	<div class="tabLeft">
	  <span class="kw">self</span>.target = <span class="kw">self</span>.node
	</div>
      </div>
      <hr/>

      <div class="pseudoCode">
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">overshotTarget</span>(<span class="kw">self</span>):<br>
	<div class="tabLeft">
	  
	</div>
      </div>
      
      
    </div>

    <div class="container">
      <h3 id="movement3">Movement 3</h3>
    </div>

    <div class="container">  
      <h3>Conclusion</h3>
      <p>So we have a Pacman object that is able to move around the screen.  That's at least more exciting than the last section, right?  We still don't have a game here, just a yellow circle that responds to certain keys.  Right now, Pacman is able to move anywhere he wants on the screen.  Last time I checked Pacman was constrained to only be able to move within a maze.  In the next section I'm going to show you how to constrain his movement by having him move on a predefined grid.</p>
    </div> <!--End of the main container-->

    <hr />

    <div class="container">
      <h2>File Structure</h2>
      <ul>
	<li>Pacman</li>
	<ul>
	  <li>constants.py</li>
	  <li>gamecontrol.py</li>
	  <li>pacman.py</li>
	  <li>stacks.py</li>
	  <li>vectors.py</li>
	</ul>
      </ul>
    </div>

    </div>
    <div class="buffer"></div>
    <footer>
      <div class="bottomNav">
	<ul>
	  <li><a href="section2.html">Previous</a></li>
	  <li><a href="#top">Top</a></li>
	  <li><a href="section4.html">Next</a></li>
	</ul>
      </div>
    </footer>
  </body>
</html>
