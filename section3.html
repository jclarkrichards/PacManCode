<!DOCTYPE html>
<html>
  <head>
    <title>Pacman Code</title>
    <link rel="stylesheet" href="style.css">
    <link href='https://fonts.googleapis.com/css?family=Poppins|Press+Start+2P' rel='stylesheet' type='text/css'>  
  </head>

  <body>
    <div id="top"></div>
    <div class="page">
    <div class="navigation">
      <header>
	<h1><img src="Images/pacman.png"/>... Pacman Code ...<img src="Images/pacman.png"/></h1>
	<hr />
	<nav>
	  <ul>
	    <li><a href="index.html">Home</a></li>
	    <li><a href="code.html">Code</a></li>
	    <li><a href="clones.html">Clones</a></li>
	    <li><a href="discuss.html">Discuss</a></li>
	    <li><a href="about.html">About</a></li>
	    <li><a href="contact.html">Contact</a></li>
	  </ul>
	</nav>
      </header>
    </div>

    <hr />
    <h2>Section 3: Moving From Node To Node</h2>
    <div class="container">
      <h3>Setup</h3>
      <p>So the whole point of creating the node map was to constrain Pacman's movement so that he can only move from node to node and nowhere else.  This section will show you how to do that.  This section is actually further divided up into three subsections because we're going to cover three types of node movement.  All of which are good to know and used in this game.  You can jump to the different sections by clicking on the links below or just read from the start.</p>
      <dl>
	<dt><a href="#movement1">Movement 1</a>:</dt>
	<dd>The simplest type of Node to Node movement.  We just jump from Node to Node with no movement in between</dd>
	<dt><a href="#movement2">Movement 2</a>:</dt>
	<dd>We show movement in between the nodes, but we will always stop on each node</dd>
	<dt><a href="#movement3">Movement 3</a>:</dt>
	<dd>The super advanced Node to Node movement that Pacman and the Ghosts will use</dd>
      </dl>
    </div>

    <div class="container">
      <h3 id="movement1">Movement 1</h3>
      <p>Having a map of connected nodes is great, but now we have to teach Pacman how to move around the maze from node to node.  The first type of movement we're going to teach him is simply jumping from node to node.  For example, if he is on Node A and Node A has a neighbor to the LEFT called Node B, then if the player pressed the LEFT key, Pacman would immediately appear on Node B without any indication of movement between the two nodes.  If Node A didn't have a neighbor to the LEFT and the player pressed the LEFT key, then nothing would happen.  This really isn't how Pacman moves around the maze, but it's a first step and has a lot of useful applications and we'll actually use it for some of the things in the game like menu selection and such.  Let's just dive right into the necessary code changes we need to make.  Surprisingly, there isn't that much we need to modify.</p>
      <hr/>

      <div class="pseudoCode">
	<p>The first thing we're going to modify is the pacman.py file.  We need to pass in the list of nodes that make up the maze.  Instead of specifying a random pixel position vector for Pacman to start out on we need to tell him which node we want him to start out on.  Right now it doesn't matter so we'll just have him start out on the first node, so we set his position to be the same as that nodes position.  So nodes is a list of the complete maze and node is the node that Pacman is currently on.  Then we call a method called <span class="mn">setPosition</span>.  We also introduce a temporary variable called "keyDown".  The only reason we have this is so Pacman will only move one node at a time with each key press.</p>
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">__init__</span>(<span class="kw">self</span>, nodes):<br>
	<div class="tabLeft">
	  <span class="kw">self</span>.nodes = nodes<br>
	  <span class="kw">self</span>.node = nodes[0]<br>
	  <span class="kw">self</span>.setPosition()<br>
	  <span class="kw">self</span>.keyDown = <span class="py">False</span>
	</div>
      </div>
      <hr/>

      <div class="pseudoCode">
	<p>All this method really does is copy the node's position to Pacman's position.  We call the copy method because we don't want the same position object associated with Pacman and the node.  If it is then modifying Pacman's position will also modify the nodes position.  The node will basically follow Pacman around.  So instead we copy the position which gives us a fresh new vector to represent Pacman's position.</p>
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">setPosition</span>(<span class="kw">self</span>):<br>
	<div class="tabLeft">
	  <span class="kw">def</span>.position = <span class="kw">self</span>.node.position.copy()
	</div>
      </div>
      <hr/>

      <div class="pseudoCode">
	<p>In the <span class="mn">update</span> method we're going to temporarily comment out the position update.  This is only temporary to show you this type of movement though.</p>
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">update</span>(<span class="kw">self</span>, dt):<br>
	<div class="tabLeft">
	  <span class="str">#self.position += self.direction*self.speed*dt</span>
	</div>
      </div>
      <hr/>

      <div class="pseudoCode">
	<p>We're going to modify the <span class="mn">move</span> method by first checking that the direction isn't equal to the STOP vector and that any keys are being held down.  If the direction is not STOP and a key is being held down, then we need to check further that the node Pacman is currently on has a neighbor in that direction.  If there isn't a neighbor in that direction, then we don't do anything.  If there is a neighbor in that direction, then we set that neighbor as Pacman's current node and call the <span class="mn">setPosition</span> method.  We then set the keyDown variable to <span class="py">True</span> so that Pacman will only move one node with every key press.  </p>
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">move</span>(<span class="kw">self</span>, direction):<br>
	<div class="tabLeft">
	  <span class="kw">self</span>.direction = direction<br>
	  <span class="kw">if self</span>.direction <span class="kw">is not</span> STOP <span class="kw"> and not self</span>.keyDown:<br>
	  <div class="tabLeft">
	    <span class="kw">if self</span>.node.neighbors[<span class="kw">self</span>.direction] <span class="kw"> is not</span> <span class="py">None</span>:<br>
	    <div class="tabLeft">
	      <span class="kw">self</span>.node = <span class="kw">self</span>.node.neighbors[<span class="kw">self</span>.direction]<br>
	      <span class="kw">self</span>.setPosition()<br>
	      <span class="kw">self</span>.keyDown = <span class="py">True</span>
	    </div>
	  </div>
	</div>
      </div>
      <hr/>

      <div class="pseudoCode">
	<p>In the gamecontrol.py method we're going to modify the <span class="mn">startGame</span> method so that we pass in the nodeList into the Pacman object.  We also change it so we create the nodes first, so create the Pacman object after we create the nodes.</p>
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">startGame</span>(<span class="kw">self</span>):<br>
	<div class="tabLeft">
	  <span class="kw">self</span>.nodes = NodeGroup()<br>
	  <span class="kw">self</span>.nodes.setupTestNodes()<br>
	  <span class="kw">self</span>.pacman = Pacman(<span class="kw">self</span>.nodes.nodeList)
	</div>
      </div>
      <hr/>
      
      <div class="pseudoCode">
	<p>In the <span class="mn">checkEvents</span> method we're going to temporarily modify it so that we can check for when the user releases the key.  In which case we reset the keyDown variable to <span class="py">False</span> again.</p>
      </div>
      <div class="codeText">
	<span class="kw">def</span> <span class="mn">checkEvents</span>(<span class="kw">self</span>):<br>
	<div class="tabLeft">
	  <span class="kw">for</span> event <span class="kw">in</span> pygame.event.get():<br>
	  <div class="tabLeft">
	    <span class="kw">if</span> event.<span class="py">type</span> == QUIT:<br>
	    <div class="tabLeft">
	      <span class="py">exit</span>()<br>
	    </div>
	    <span class="kw">elif</span> event.<span class="py">type</span> == KEYUP:<br>
	    <div class="tabLeft">
	      <span class="kw">self</span>.pacman.keyDown = <span class="py">False</span>
	    </div>
	  </div>
	</div>
      </div>
      </div>
   

    <div class="container">
      <h3 id="movement2">Movement 2</h3>
    </div>

    <div class="container">
      <h3 id="movement3">Movement 3</h3>
    </div>

    <div class="container">  
      <h3>Conclusion</h3>
      <p>So we have a Pacman object that is able to move around the screen.  That's at least more exciting than the last section, right?  We still don't have a game here, just a yellow circle that responds to certain keys.  Right now, Pacman is able to move anywhere he wants on the screen.  Last time I checked Pacman was constrained to only be able to move within a maze.  In the next section I'm going to show you how to constrain his movement by having him move on a predefined grid.</p>
    </div> <!--End of the main container-->

    <hr />

    <div class="container">
      <h2>File Structure</h2>
      <ul>
	<li>Pacman</li>
	<ul>
	  <li>constants.py</li>
	  <li>gamecontrol.py</li>
	  <li>pacman.py</li>
	  <li>stacks.py</li>
	  <li>vectors.py</li>
	</ul>
      </ul>
    </div>

    </div>
    <div class="buffer"></div>
    <footer>
      <div class="bottomNav">
	<ul>
	  <li><a href="section2.html">Previous</a></li>
	  <li><a href="#top">Top</a></li>
	  <li><a href="section4.html">Next</a></li>
	</ul>
      </div>
    </footer>
  </body>
</html>
